/* 
 * **************************************************************************
 * 
 *  file:       gcodewriter.cpp
 *  project:    kuteCAM
 *  subproject: main application
 *  purpose:    create gcode for toolpaths created from CAD models
 *  created:    11.4.2022 by Django Reinhard
 *  copyright:  2022 - 2022 Django Reinhard -  all rights reserved
 * 
 *  This program is free software: you can redistribute it and/or modify 
 *  it under the terms of the GNU General Public License as published by 
 *  the Free Software Foundation, either version 2 of the License, or 
 *  (at your option) any later version. 
 *   
 *  This program is distributed in the hope that it will be useful, 
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of 
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 *  GNU General Public License for more details. 
 *   
 *  You should have received a copy of the GNU General Public License 
 *  along with this program.  If not, see <https://www.gnu.org/licenses/>.
 * 
 * **************************************************************************
 */
#include "gcodewriter.h"
#include "core.h"
#include "drilltargetdefinition.h"
#include "sweeptargetdefinition.h"
#include "operation.h"
#include "postprocessor.h"
#include "toolentry.h"
#include "toollistmodel.h"
#include "workstep.h"
#include "wsarc.h"
#include "wsstraightmove.h"
#include "wstraverse.h"
#include <QFile>
#include <QTextStream>


GCodeWriter::GCodeWriter(PostProcessor* pp)
 : pp(pp) {
  }


int GCodeWriter::processOperations(const QString& fileName, const Bnd_Box& wpBounds, const QVector<Operation *>& operations) {
  QFile file(fileName);

  if (!file.open(QIODevice::WriteOnly | QIODevice::Text))
     return -1;
  QTextStream out(&file);
  int         mxOP = operations.size();
  double      rotA = 0, rotB = 0, rotC = 0;
  ToolEntry*  curTool;
  Operation*  curOP;
  Operation*  nxtOP;

  if (!operations.size()) return -2;
  curOP = operations.at(0);
  curTool = Core().toolListModel()->tool(Core().toolListModel()->findToolNum(curOP->toolNum()));

  writeLine(out
          , pp->genProminentComment(QString("Job %1").arg(file.fileName())));
  writeLine(out
          , pp->genProminentComment(QString("generated by %1").arg(Core().appName())));
  writeLine(out
          , pp->genDefineWorkpiece(wpBounds.CornerMin(), wpBounds.CornerMax()));
  writeLine(out
          , pp->genJobIntro());
  writeLine(out
          , pp->genPrepareTool(curTool));
  writeLine(out
          , pp->genToolChange());
  writeLine(out);

  for (int i=0; i < mxOP; ++i) {
      curOP   = operations.at(i);
      nxtOP   = i < (mxOP - 1) ? operations.at(i + 1) : operations.at(0);
      curTool = Core().toolListModel()->tool(Core().toolListModel()->findToolNum(curOP->toolNum()));

      if (i) {
         writeLine(out, pp->genToolChange());
         writeLine(out);
         }

      if (curOP->operationA() != rotA
       || curOP->operationB() != rotB
       || curOP->operationC() != rotC) {        
         // rotation changed ...
         rotA = Core().isAaxisTable() ? -curOP->operationA() : curOP->operationA();
         rotB = Core().isBaxisTable() ? -curOP->operationB() : curOP->operationB();
         rotC = Core().isCaxisTable() ? -curOP->operationC() : curOP->operationC();

         writeLine(out
                 , pp->genRotation(rotA, rotB, rotC));

         writeLine(out);
         }
      writeLine(out
              , pp->genProminentComment(curOP->name()));
      writeLine(out
              , pp->genProminentComment(QString("T%1 %2 - D:%3 L:%4")
                                           .arg(curTool->toolNumber())
                                           .arg(curTool->toolName())
                                           .arg(curTool->fluteDiameter())
                                           .arg(curTool->freeLength())));
      double  speed = curOP->speed() * 1000 / M_PI / curTool->fluteDiameter();
      gp_Pnt  pos;

      if (curOP->workSteps().size()) pos = curOP->workSteps().at(0)->startPos();
      writeLine(out
              , pp->genOPIntro(i + 1
                             , curOP->fixture()
                             , pos
                             , speed
                             , curTool
                             , curOP->cooling()
                             , nxtOP->toolNum()));

      switch (curOP->kind()) {
        case ContourOperation: processContourTargets(out, curOP, curTool); break;
        case DrillOperation:   processDrillTargets(out,   curOP, curTool); break;
        case SweepOperation:   processSweepTargets(out,   curOP, curTool); break;
        }
      writeLine(out, pp->genOPExit());
      }
  writeLine(out);
  writeLine(out, pp->genJobExit());

  return 0;
  }


void GCodeWriter::processContourTargets(QTextStream& out, const Operation* op, ToolEntry* curTool) {
  writeLine(out, pp->genProminentComment("contour-target - NOT IMPLEMENTED YET!"));
  }


void GCodeWriter::processDrillTargets(QTextStream& out, const Operation* op, ToolEntry* curTool) {
  double ss   = op->speed() * 1000 / M_PI / curTool->fluteDiameter();
  double feed = ss * curTool->numFlutes() * op->feedPerTooth();

  writeLine(out, pp->genDefineCycle(op->drillCycle()
                                  , op->safeZ0()
                                  , op->safeZ1()
                                  , op->finalDepth()
                                  , op->qMin()
                                  , op->qMax()
                                  , op->retract()
                                  , op->dwell()
                                  , feed
                                    ));
  for (int i=1; i < op->workSteps().size(); ++i) {
      Workstep* ws = op->workSteps().at(i);

      writeLine(out
              , pp->genExecCycle(op->drillCycle(), ws->startPos().X(), ws->startPos().Y()));
      }
  }


void GCodeWriter::processSweepTargets(QTextStream& out, const Operation* op, ToolEntry* curTool) {
  double ss   = op->speed() * 1000 / M_PI / curTool->fluteDiameter();
  double feed = ss * curTool->numFlutes() * op->feedPerTooth();
  WorkstepType lastMove = WTCycle;
  QString cmd;

  for (int i=0; i < op->workSteps().size(); ++i) {
      Workstep*       ws = op->workSteps().at(i);
      WSArc*          wa = static_cast<WSArc*>(ws);
      WSStraightMove* wm = static_cast<WSStraightMove*>(ws);
      WSTraverse*     wt = static_cast<WSTraverse*>(ws);

      switch (ws->type()) {
        case WTTraverse:
             cmd = pp->genTraverse(wt->startPos(), wt->endPos(), lastMove);
             lastMove = WTTraverse;
             break;
        case WTStraightMove:
             cmd = pp->genStraightMove(wm->startPos(), wm->endPos(), feed);
             lastMove = WTStraightMove;
             break;
        case WTArc:
             cmd = pp->genArc(wa->startPos(), wa->endPos(), wa->centerPos(), wa->isCCW(), feed);
             lastMove = WTArc;
             break;
        default: break;
        }
      writeLine(out, cmd);
      }
  }


void GCodeWriter::writeLine(QTextStream &out, const QString &line) {
  out << line << pp->genEndOfLine();
  out.flush();
  }

