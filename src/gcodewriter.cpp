/* 
 * **************************************************************************
 * 
 *  file:       gcodewriter.cpp
 *  project:    kuteCAM
 *  subproject: main application
 *  purpose:    create a graphical application, that assists in identify
 *              and process model elements                        
 *  created:    11.4.2022 by Django Reinhard
 *  copyright:  (c) 2022 Django Reinhard -  all rights reserved
 * 
 *  This program is free software: you can redistribute it and/or modify 
 *  it under the terms of the GNU General Public License as published by 
 *  the Free Software Foundation, either version 2 of the License, or 
 *  (at your option) any later version. 
 *   
 *  This program is distributed in the hope that it will be useful, 
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of 
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 *  GNU General Public License for more details. 
 *   
 *  You should have received a copy of the GNU General Public License 
 *  along with this program.  If not, see <https://www.gnu.org/licenses/>.
 * 
 * **************************************************************************
 */
#include "gcodewriter.h"
#include "core.h"
#include "drilltargetdefinition.h"
#include "sweeptargetdefinition.h"
#include "operation.h"
#include "postprocessor.h"
#include "projectfile.h"
#include "toolentry.h"
#include "toollistmodel.h"
#include "workstep.h"
#include "wsarc.h"
#include "wsstraightmove.h"
#include "wstraverse.h"
#include <QDir>
#include <QFile>
#include <QFileInfo>
#include <QTextStream>


GCodeWriter::GCodeWriter(PostProcessor* pp)
 : pp(pp)
 , rotA(0)
 , rotB(0)
 , rotC(0) {
  }


int GCodeWriter::processSingleOPs(const QString& baseName, const Bnd_Box& wpBounds, const QVector<Operation *>& operations, bool genTC) {
  QFileInfo    fi(baseName);
  ProjectFile* pf = Core().projectFile();
  int          mxOP = operations.size();

  pf->beginGroup("Setup");
  QString      modelFile = pf->value("Model-File").toString();
  QStringList  modelComment = pf->value("model-comment").toString().split("\n");
  pf->endGroup();

  for (int i=0; i < mxOP; ++i) {
      QString   opName   = QString("%1/%2%3").arg(fi.dir().path(), fi.baseName())
                                             .arg(i, 4, 'f', 0, '0');
      QString   fileName = QString("%1.%2").arg(opName, pp->getFileExtension());
      QFileInfo pfi(fileName);
      QFile     file(fileName);

      if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) return -1;
      QTextStream  out(&file);

      writeLine(out
              , pp->genProminentComment(QString("Job %1").arg(opName)));
      writeLine(out
              , pp->genProminentComment(QString("generated by %1").arg(Core().appName())));
      writeLine(out
              , pp->genProminentComment(QString("project file: %1").arg(pf->fileName())));
      writeLine(out
              , pp->genProminentComment(QString("model file: %1").arg(modelFile)));
      for (const QString& s : modelComment) {
          writeLine(out
                   , pp->genProminentComment(s));
          }
      writeLine(out
              , pp->genJobIntro(pfi.baseName()));
      writeLine(out
              , pp->genDefineWorkpiece(wpBounds.CornerMin(), wpBounds.CornerMax()));

      processOperation(out
                     , i
                     , pfi.baseName()
                     , wpBounds
                     , operations.at(i)
                     , i < (mxOP - 1) ? operations.at(i + 1) : operations.at(0)
                     , genTC
                       );
      writeLine(out, pp->genJobExit(opName));
      file.flush();
      file.close();
      }
  return 0;
  }


void GCodeWriter::processOperation(QTextStream &out, int n, const QString& opName, const Bnd_Box& wpBounds, const Operation *op, const Operation *nxtOP, bool genTC) {
  ToolEntry* curTool = Core().toolListModel()->tool(Core().toolListModel()->findToolNum(op->toolNum()));

  if (genTC) {
     if (!n) writeLine(out
                     , pp->genPrepareTool(op->toolNum()));
     writeLine(out
             , pp->genToolChange());
     }
  writeLine(out);
  if (op->operationA() != rotA
   || op->operationB() != rotB
   || op->operationC() != rotC) {
     // rotation changed ...
     rotA = Core().isAAxisTable() ? -op->operationA() : op->operationA();
     rotB = Core().isBAxisTable() ? -op->operationB() : op->operationB();
     rotC = Core().isCAxisTable() ? -op->operationC() : op->operationC();

     writeLine(out
             , pp->genRotation(rotA, rotB, rotC));

     writeLine(out);
     }
  writeLine(out
          , pp->genProminentComment(QString("Operation: %1").arg(op->name())));
  writeLine(out
          , pp->genProminentComment(QString("T%1 %2 - D:%3 L:%4")
                                       .arg(curTool->toolNumber())
                                       .arg(curTool->toolName())
                                       .arg(curTool->fluteDiameter())
                                       .arg(curTool->freeLength())));
  double  speed = op->speed() * 1000 / M_PI / curTool->fluteDiameter();
  double  feed  = speed * curTool->numFlutes() * op->feedPerTooth();
  int     line  = 0;
  gp_Pnt  pos;

  if (op->workSteps().size()) {
     for (; line < op->workSteps().size(); ++line) {
         pos = op->workSteps().at(line)->startPos();
         if (pos.Z() >= 300) continue;
         break;
         }
     }
  writeLine(out
          , pp->genOPIntro(n + 1
                         , op->fixture()
                         , pos
                         , speed
                         , feed
                         , op->toolNum()
                         , op->cooling()
                         , nxtOP->toolNum()));

  switch (op->kind()) {
    case ContourOperation:
    case SweepOperation:
    case ClampingPlugOP:
         processPathTargets(out, op, line, curTool);
         break;
    case DrillOperation:
         processDrillTargets(out, op, line, curTool);
         writeLine(out
                 , pp->genEndCycle());
         break;
    }
  writeLine(out, pp->genOPExit());
  writeLine(out);
  out.flush();
  }


int GCodeWriter::processAllInOne(const QString& fileName, const Bnd_Box& wpBounds, const QVector<Operation *>& operations) {
  QFile file(fileName);

  if (!file.open(QIODevice::WriteOnly | QIODevice::Text))
     return -1;
  QTextStream  out(&file);
  QFileInfo    fi(fileName);
  ProjectFile* pf = Core().projectFile();
  int          mxOP = operations.size();
  gp_Pnt       lastPos(0, 0, 300);

  pf->beginGroup("Setup");
  QString      modelFile = pf->value("Model-File").toString();
  QStringList  modelComment = pf->value("model-comment").toString().split("\n");
  pf->endGroup();

  writeLine(out
          , pp->genProminentComment(QString("Job %1").arg(fi.baseName())));
  writeLine(out
          , pp->genProminentComment(QString("generated by %1").arg(Core().appName())));
  writeLine(out
          , pp->genProminentComment(QString("project file: %1").arg(pf->fileName())));
  writeLine(out
          , pp->genProminentComment(QString("model file: %1").arg(modelFile)));
  for (const QString& s : modelComment) {
      writeLine(out
               , pp->genProminentComment(s));
      }
  writeLine(out
          , pp->genJobIntro(fi.baseName()));
  writeLine(out
          , pp->genDefineWorkpiece(wpBounds.CornerMin(), wpBounds.CornerMax()));

  for (int i=0; i < mxOP; ++i) {
      pp->setLastPos(lastPos);
      processOperation(out
                     , i
                     , fi.baseName()
                     , wpBounds
                     , operations.at(i)
                     , i < (mxOP - 1) ? operations.at(i + 1) : operations.at(0)
                     , true
                       );
      lastPos = pp->lastPos();
      }
  writeLine(out, pp->genJobExit(fi.baseName()));
  file.flush();
  file.close();

  return 0;
  }


void GCodeWriter::processDrillTargets(QTextStream& out, const Operation* op, int, ToolEntry* curTool) {
  double ss   = op->speed() * 1000 / M_PI / curTool->fluteDiameter();
  double feed = ss * curTool->numFlutes() * op->feedPerTooth();

  writeLine(out, pp->genDefineCycle(op->drillCycle()
                                  , op->upperZ()
                                  , op->safeZ0()
                                  , op->safeZ1()
                                    //TODO: check it out!
                                  , op->drillDepth()
                                  , op->qMin()
                                  , op->qMax()
                                  , op->retract()
                                  , op->dwell()
                                  , feed
                                    ));
  for (int i=1; i < op->workSteps().size(); ++i) {
      Workstep* ws = op->workSteps().at(i);

      writeLine(out
              , pp->genExecCycle(op->drillCycle(), ws->startPos().X(), ws->startPos().Y()));
      }
  }


void GCodeWriter::processPathTargets(QTextStream& out, const Operation* op, int first, ToolEntry* curTool) {
  double ss   = op->speed() * 1000 / M_PI / curTool->fluteDiameter();
  double feed = ss * curTool->numFlutes() * op->feedPerTooth();
  WorkstepType lastMove = WTCycle;
  QString cmd;

  for (int i=first; i < op->workSteps().size(); ++i) {
      Workstep*       ws = op->workSteps().at(i);
      WSArc*          wa = dynamic_cast<WSArc*>(ws);
      WSStraightMove* wm = dynamic_cast<WSStraightMove*>(ws);
      WSTraverse*     wt = dynamic_cast<WSTraverse*>(ws);

      switch (ws->type()) {
        case WTTraverse:
             cmd = pp->genTraverse(wt->endPos(), lastMove);
             lastMove = WTTraverse;
             break;
        case WTStraightMove:
             cmd = pp->genStraightMove(wm->endPos(), i == first ? feed : 0);
             lastMove = WTStraightMove;
             break;
        case WTArc:
             cmd = pp->genArc(wa->endPos(), wa->centerPos(), wa->isCCW(), i == first ? feed : 0);
             lastMove = WTArc;
             break;
        default: break;
        }
      writeLine(out, cmd);
      }
  }


void GCodeWriter::writeLine(QTextStream &out, const QString &line) {
  out << line << pp->genEndOfLine();
  out.flush();
  }

